
Ограниченность памяти и переполнение
Вы уже знаете, что целочисленные типы данных отличаются диапазоном значений. Если значение переменной находится вне диапазона значений указанного типа, происходит переполнение.
Рассмотрим примеры. Возьмём максимальное значение типа int и прибавим к нему единицу:

#include <iostream>
#include <limits>

using namespace std;

int main() {
    cout << numeric_limits<int>::max() + 1 << endl;
} 

Современные компиляторы даже выдадут предупреждение, что мы встали на скользкую дорожку:

 warning: integer overflow in expression of type ‘int’ results in ‘-2147483648’ [-Woverflow] 

И действительно, при запуске вместо ожидаемого 2 147 483 648 получаем отрицательное число — минимальное значение типа int:

-2147483648 

Это произошло, потому что значение выражения в int не поместилось.
Теперь возьмём значение меньше минимального:

cout << numeric_limits<int>::min() - 1 << endl; 

Снова предупреждение и снова не то, чего ожидали:

2147483647 

Берём число на единицу больше, чем максимум, — получаем минимум. Берём число на единицу меньше, чем минимум, — получаем максимум. Такое в С++ переполнение.
Более практичный пример. Допустим, у нас есть два числа типа int: два миллиарда и один миллиард. Вычислим среднее арифметическое. Оба числа не превышают максимального значения int. Предполагаем, что их среднее арифметическое не превысит два миллиарда и тоже поместится в int. Спокойно пишем программу:

// разряды в больших числах удобно разделять символом '
int x = 2'000'000'000;
int y = 1'000'000'000;
cout << (x + y) / 2 << endl; 

Вместо ожидаемых полутора миллиардов получаем:

-647483648 

С++ сначала выполнил действие в скобках: сложил x и y. Получилось три миллиарда — число, которое превышает максимальное значение типа int. После этого всё и пошло наперекосяк.
Выбирая тип данных, нужно продумать каждый сегмент программы. Если промежуточные вычисления не поместятся в ваш тип, рискуете получить большое отрицательное число — верный признак переполнения. А когда выполняете серию арифметических операций, переполнение можете и вовсе не заметить.
Посмотрим, как это работает с беззнаковыми типами. Сохраним переменную x со значением два миллиарда в беззнаковую переменную y и выведем обе:

int x = 2'000'000'000;
unsigned int y = x;
cout << x << " "s << y << endl; 

Запустим код и увидим, что всё в порядке, ведь это значение помещается и в int, и в unsigned int:

2000000000 2000000000 

Теперь сохраним в переменную x отрицательное значение:

int x = -2'000'000'000;
unsigned int y = x;
cout << x << " "s << y << endl; 

Запустим код. В беззнаковый тип наше значение не поместилось:

-2000000000 2294967296 

Так происходит переполнение беззнакового целочисленного типа.
С одним беззнаковым типом мы уже сталкивались — это тип size_t. Во-первых, именно его возвращает метод size контейнеров. Во-вторых, результат вызова оператора sizeof тоже имеет тип size_t. Это вполне логично: размер чего-либо не может быть отрицательным.
Размер самого типа size_t зависит от разрядности вашей операционной системы. Если система 32-битная — размер size_t составит 32 бита (четыре байта), если 64-битная — 64 бита (восемь байт).
Вернёмся к задаче о среднем рейтинге. Имея рейтинги −5, 1 и −2, найдём их среднее арифметическое:

#include <iostream>
#include <vector>

using namespace std;

int ComputeAverageRating(const vector<int>& ratings) {
    if (ratings.empty()) {
        return 0;
    }
    int rating_sum = 0;
    for (const int rating : ratings) {
        rating_sum += rating;
    }
    return rating_sum / ratings.size();
}

int main() {
    cout << ComputeAverageRating({1, -7, 3}) << endl;
} 

Средний рейтинг должен составить (−5+1−2) / 3 = −2. Но результат намекает на переполнение:

1431655763 

Дело в финальном выражении функции: rating_sum / ratings.size(). Чтобы разделить int на size_t, компилятор привёл оба операнда к беззнаковому типу. В нём −2 не сохранить.
Поэтому и помогало предварительно привести размер вектора к знаковому типу int:

return rating_sum / static_cast<int>(ratings.size()); 

Избегайте переполнения типов: даже если код работает при ваших текущих настройках, он может дать сбой на другом компиляторе или ОС. Ситуаций, когда переполнение приносит пользу, — мало. Едва ли вы с ними столкнётесь.
Выбирайте подходящие типы и преобразовывайте их оператором static_cast. В следующем уроке вы научитесь этому на конкретных примерах и узнаете о нюансах приведения операндов к общему типу.
